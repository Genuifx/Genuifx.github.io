<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="javascript," />










<meta name="description" content="前言在上一章我们提出了一个promise和setTimeout回调执行顺序的疑问，并且一起研究了promise-polyfill的源码实现。然而，最初的问题还是没有得到解答，同时引出了更多的关于异步时序的思考，为了真正解决这个问题，我们必须深入理解一些js实现底层的东西。 热身我们从下面这张经典图解开始了解，（引用自Robert） 这是一张js实现的模型图，请注意我的措辞“js实现”；实际上ecm">
<meta name="keywords" content="javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="从Promise到Event Loop（二）">
<meta property="og:url" content="http://yoursite.com/2018/04/12/from-promise-polyfill-to-event-loop-2/index.html">
<meta property="og:site_name" content="Genuifx">
<meta property="og:description" content="前言在上一章我们提出了一个promise和setTimeout回调执行顺序的疑问，并且一起研究了promise-polyfill的源码实现。然而，最初的问题还是没有得到解答，同时引出了更多的关于异步时序的思考，为了真正解决这个问题，我们必须深入理解一些js实现底层的东西。 热身我们从下面这张经典图解开始了解，（引用自Robert） 这是一张js实现的模型图，请注意我的措辞“js实现”；实际上ecm">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/eventloop/model.png">
<meta property="og:image" content="http://yoursite.com/images/1_tqkykdU69DFrxi82JOWLbQ.png">
<meta property="og:image" content="http://yoursite.com/images/eventloop/WX20180327-233228.png">
<meta property="og:image" content="http://yoursite.com/images/eventllop/v2-a0322f548ad45bf527ab36ae76b5b11b_r.jpg">
<meta property="og:image" content="http://yoursite.com/images/eventloop/1_tqkykdU69DFrxi82JOWLbQ.png">
<meta property="og:image" content="http://yoursite.com/images/eventloop/nodejs-EventLoop.jpg">
<meta property="og:image" content="http://yoursite.com/images/eventloop/node-event-loop.png">
<meta property="og:updated_time" content="2018-04-12T08:29:03.332Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从Promise到Event Loop（二）">
<meta name="twitter:description" content="前言在上一章我们提出了一个promise和setTimeout回调执行顺序的疑问，并且一起研究了promise-polyfill的源码实现。然而，最初的问题还是没有得到解答，同时引出了更多的关于异步时序的思考，为了真正解决这个问题，我们必须深入理解一些js实现底层的东西。 热身我们从下面这张经典图解开始了解，（引用自Robert） 这是一张js实现的模型图，请注意我的措辞“js实现”；实际上ecm">
<meta name="twitter:image" content="http://yoursite.com/images/eventloop/model.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/04/12/from-promise-polyfill-to-event-loop-2/"/>





  <title>从Promise到Event Loop（二） | Genuifx</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Genuifx</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">世界和平</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/12/from-promise-polyfill-to-event-loop-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iveswen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Genuifx">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">从Promise到Event Loop（二）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-12T15:59:09+08:00">2018-04-12</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="../from-promise-polyfill-to-eventloop">上一章</a>我们提出了一个promise和setTimeout回调执行顺序的疑问，并且一起研究了promise-polyfill的源码实现。然而，最初的问题还是没有得到解答，同时引出了更多的关于异步时序的思考，为了真正解决这个问题，我们必须深入理解一些js实现底层的东西。</p>
<h2 id="热身"><a href="#热身" class="headerlink" title="热身"></a>热身</h2><p>我们从下面这张经典图解开始了解，（引用自<a href="http://vimeo.com/96425312" title="Robert" target="_blank" rel="external">Robert</a>）<br><img src="/images/eventloop/model.png" alt="js模型图" title="js模型图"></p>
<p>这是一张js实现的模型图，请注意我的措辞“js实现”；实际上ecmascript并没有规定任何Event Loop的实现内容（划重点），如果去搜v8的源码，你会发现上图右边的web api实现都找不到，不管是XMLHttpRequest还是setTimeout的实现，我们都找不到出处。</p>
<p>原因很简单，web api 或者说 BOM，DOM这些都不是ecma的语言规范。</p>
<p>图中的内容老生常谈了，几乎每个js教程关于Event Loop都会挂这个，但还是稍微介绍一下：</p>
<h3 id="1-heap（堆）"><a href="#1-heap（堆）" class="headerlink" title="1. heap（堆）"></a>1. heap（堆）</h3><p>用于分配对象，对象名实际上一个指向一堆无结构的内存区域（同C语言的结构体？），需要注意的是，当我们形成闭包的时候，实际上作用域链也是保存到堆了。</p>
<h3 id="2-stack（栈）"><a href="#2-stack（栈）" class="headerlink" title="2. stack（栈）"></a>2. stack（栈）</h3><p>函数调用栈，当调用一个函数的时候，我们把函数入栈，当函数执行完毕，则从当前栈中弹出函数，并且继续执行下一个函数。javascript是单线程的语言主要是提现在这里，因为一个“thread”只有一个调用栈，所以一个时间片下永远都只能“专心”处理一件事，调用栈同样有调用深度的限制，一个无限循环自我调用的函数会把栈搞爆。<br><img src="/images/1_tqkykdU69DFrxi82JOWLbQ.png" alt=""></p>
<blockquote>
<p>引用自Medium</p>
</blockquote>
<h3 id="3-Event-Loop"><a href="#3-Event-Loop" class="headerlink" title="3. Event Loop"></a>3. Event Loop</h3><p>一个不断执行的循环，不断的从任务队列或者说消息队列读取需要执行的回调函数，当函数执行的时候，会执行入栈操作<br>所有例如<code>setTimeout(fn, 0)</code>这种操作并不能保证当前函数执行完了之后马上就运行，会有排队的延迟。zakas在<a href="https://www.nczonline.net/blog/2011/09/19/script-yielding-with-setimmediate/" target="_blank" rel="external">这篇文章</a>中还提到了timer的解析和耗电问题💯<br>Event Loop的实现一般看起来长这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (queue.waitForMessage()) &#123;</div><div class="line">  queue.processNextMessage();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ok，热身完毕，正餐开始。</p>
<h2 id="并发模型和事件循环"><a href="#并发模型和事件循环" class="headerlink" title="并发模型和事件循环"></a>并发模型和事件循环</h2><h3 id="以“Thread”为单位"><a href="#以“Thread”为单位" class="headerlink" title="以“Thread”为单位"></a>以“Thread”为单位</h3><p>我们常说javascript是单线程语言，首先需要明确一点的是上述的heap，stack和Event Loop都在一个“thread”下执行，对于chrome来说，每个window（页面窗口）就是一个“thread”，所以只有同一个“thread”下面的函数或者对象才能相互交流，而web worker和非同源的iframe都有自己独有的thread，相互之间并不能直接交流。</p>
<h3 id="Event-Loop-依赖js宿主环境实现"><a href="#Event-Loop-依赖js宿主环境实现" class="headerlink" title="Event Loop 依赖js宿主环境实现"></a>Event Loop 依赖js宿主环境实现</h3><p>ecma的spec并没有规定Event Loop应该怎么设计，这就决定了在不同的浏览器，不同的宿主环境（node，嵌入式）其Event Loop的实现不同，表现也不禁相同。</p>
<p>故而，promise与setTimeout的回调执行先后问题，实际上在不同浏览器不同版本运行结果都不相同。而由于没有规范规定实现，所有你不能说某个浏览器的是错误的，只能说哪种实现更为合理（当然现代浏览器的实现已经趋于一致。<br><img src="/images/eventloop/WX20180327-233228.png" alt=""></p>
<blockquote>
<p>同一份代码在不同浏览器的运行结果, 引用自<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="external">jake</a></p>
</blockquote>
<h3 id="Event-Loop-是类似队列（queue-like）的结构"><a href="#Event-Loop-是类似队列（queue-like）的结构" class="headerlink" title="Event Loop 是类似队列（queue-like）的结构"></a>Event Loop 是类似队列（queue-like）的结构</h3><p>对node来说，Event Loop不是一个单纯的队列，而是由一个个Phase和Tick组成，每个Phase和Tick又有自己的任务队列。详见下文。<br>对chrome来说，Event Loop又分为Task（又叫MarcoTask）和MicroTask，各有自己任务队列，详见下文。<br>其他浏览器的资料由于闭源，网上没有找到相关资料，但是从表现上看估计实现差不多。如果有相关的信息欢迎分享链接。<br>故而，Event Loop从宏观的角度看的确是一个依次执行任务队列，但从微观实现而言并非简单的队列便万事大吉。</p>
<h3 id="Ecma-262的Jobs和Job-Queues"><a href="#Ecma-262的Jobs和Job-Queues" class="headerlink" title="Ecma-262的Jobs和Job Queues"></a>Ecma-262的Jobs和Job Queues</h3><p>上面我们说过，ecma并没有Event Loop的规范，但是如果读过ecma-262的spec的同学就会发现，在<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues" target="_blank" rel="external">8-4</a>有一个神奇的Jobs和Job Queues章节，被光速打脸了吗？不存在的</p>
<p>ecma的Jobs实际上为promise定义了标准实现。由于在es6，promise已经成为了语言标准之一，而ecma的引擎需要不依赖宿主实现promise，例如V8能够脱离浏览器单独运行，在没有浏览器webApi支持的情况下依然要支持promise实现。所以spec里面有这边规定并不奇怪。</p>
<p>所以Jobs Queues和Event Loop实际上是两个东西，那么当V8在chrome运行的时候，就会有一个问题，promise的回调应该在哪里运行？<br>如果在V8，Event Loop将无法知道捕获promise相关任务，二者并不能协调工作。<br>如果在Event Loop，必须覆盖了V8的相关实现。<br>于是Html5规范规定了宿主环境必须覆盖实现ecma的Job Queues，也是就是说在浏览器环境实际上promise的回调处理由Event Loop接手。<br><img src="/images/eventllop/v2-a0322f548ad45bf527ab36ae76b5b11b_r.jpg" alt=""></p>
<h2 id="Chrome的Task和MicroTask"><a href="#Chrome的Task和MicroTask" class="headerlink" title="Chrome的Task和MicroTask"></a>Chrome的Task和MicroTask</h2><p>Tasks一般被设计为浏览器能够介入其执行间歇，以便响应用户的操作，刷新UI，不管是页面的点击或者滚动事件，如果执行栈被阻塞的了，用户将会感觉到明显的卡顿。<br><img src="/images/eventloop/1_tqkykdU69DFrxi82JOWLbQ.png" alt=""></p>
<p>MicroTask一般则为了快速响应回调处理，如果当前调用栈没有其他执行函数的话，就会尽快的按照顺序调用对应回调，所以如果当前上下文已经没有待处理函数，或者两个Task之间的间歇都会执行MicroTask。值得注意的是，如果当前执行的MicroTask又动态添加了一个MicroTask的话，新的MicroTask会在这个周期内马上执行~</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>属于Task的的回调类型有： <code>setTimeout</code>，<code>XMLHttpRequest</code>， <code>IndexDB</code>，<code>事件IO</code>，<code>postMessage</code><br>属于MicroTask的回调类型有：<code>Promise</code>，<code>MutationObserver</code></p>
<h3 id="执行规则"><a href="#执行规则" class="headerlink" title="执行规则"></a>执行规则</h3><ol>
<li>Task回调按照顺序一个个执行，每个Task之间允许浏览器进行UI渲染</li>
<li>MicroTask回调按照顺序一个个执行，并且有以下执行时机</li>
</ol>
<p>关于chrome的Task和MicroTask主要从jake大大（google chrome技术支持）的<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="external">文章</a>中了解到，如果有大佬对这方面有更深入的了解的话，评论，rtx求指教！！！</p>
<h2 id="node的Libuv"><a href="#node的Libuv" class="headerlink" title="node的Libuv"></a>node的Libuv</h2><p>同chrome，node也是使用V8引擎编译，解释ecma的语法。如果你认真看了前文，就知道node需要实现自己的EventLoop机制，以保证单线程的js能以异步方式处理并发事务。</p>
<p>node的Event Loop实现全部在<a href="http://nikhilm.github.io/uvbook/introduction.html#background" target="_blank" rel="external">Libuv</a></p>
<blockquote>
<p>The node.js project began in 2009 as a JavaScript environment decoupled from the browser. Using Google’s V8 and Marc Lehmann’s libev, node.js combined a model of I/O – evented – with a language that was well suited to the style of programming; due to the way it had been shaped by browsers. As node.js grew in popularity, it was important to make it work on Windows, but libev ran only on Unix. The Windows equivalent of kernel event notification mechanisms like kqueue or (e)poll is IOCP. libuv was an abstraction around libev or IOCP depending on the platform, providing users an API based on libev. In the node-v0.9.0 version of libuv libev was removed.</p>
</blockquote>
<p>一开始的node.js实现并不支持window环境，后来用户越来越多了，需要支持window环境，但是原来的libev又不支持，于是大佬们便自己整了一个libuv，实现了node自己的事件循环机制，抹平了底层差异，对Module提供统一的api。</p>
<p>当实例化一个node应用的时候，libuv会初始化一个线程池用于处理一些没有操作系统API支持的异步事件。也就是说libuv并非独立于js运行时，他和V8应该在一个线程下工作，异步IO处理也并非都在单独线程，libuv会优先使用系统提供API进行处理。</p>
<p><img src="/images/eventloop/nodejs-EventLoop.jpg" alt=""></p>
<h3 id="Libuv的Event-Loop"><a href="#Libuv的Event-Loop" class="headerlink" title="Libuv的Event Loop"></a>Libuv的Event Loop</h3><p>Libuv的Event Loop和chrome的类似，分为<em><code>phase</code></em>和<em><code>tick</code></em>，phase又有细分的种类，tick跟MicroTask类似，用于执行需要在当前运行时执行完毕后马上执行的事件回调，例如<code>promise</code>, <code>process.nextTick</code></p>
<p><img src="/images/eventloop/node-event-loop.png" alt=""></p>
<p><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="external">nodejs官方示例</a>：<br>   ┌───────────────────────┐<br>┌─&gt;│        timers         │<br>│  └──────────┬────────────┘<br>│  ┌──────────┴────────────┐<br>│  │     I/O callbacks     │<br>│  └──────────┬────────────┘<br>│  ┌──────────┴────────────┐<br>│  │     idle, prepare     │<br>│  └──────────┬────────────┘      ┌───────────────┐<br>│  ┌──────────┴────────────┐      │   incoming:   │<br>│  │         poll          │&lt;─────┤  connections, │<br>│  └──────────┬────────────┘      │   data, etc.  │<br>│  ┌──────────┴────────────┐      └───────────────┘<br>│  │        check          │<br>│  └──────────┬────────────┘<br>│  ┌──────────┴────────────┐<br>└──┤    close callbacks    │<br>   └───────────────────────┘</p>
<p>libuv会循环的执行执行每个phase的相应队列，FIFO原则。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>所有通过setTimeout，setInterval调度的事件回调都在这里得到处理</p>
<h3 id="IO-callback"><a href="#IO-callback" class="headerlink" title="IO callback"></a>IO callback</h3><p>绝大部分回调处理的时机，包括http请求引发的回调，文件读写IO回调</p>
<h3 id="IO-Polling"><a href="#IO-Polling" class="headerlink" title="IO Polling"></a>IO Polling</h3><p>给下一轮循环收集新的事件</p>
<h3 id="Immediate"><a href="#Immediate" class="headerlink" title="Immediate"></a>Immediate</h3><p>通过setImmediate调度的事件回调处理</p>
<h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><p>处理所有的.on(‘close’)事件回调</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>综上所述：</p>
<ol>
<li>不同的宿主环境实现Event Loop不同</li>
<li>promise在不同浏览器不同版本执行顺序都有可能不一样，依赖实现</li>
<li>js是一个单线程语言，依赖异步模型达到并发效果</li>
<li>代码层面不要让<code>Promise.resolve</code>和<code>setTimeout(fn, 0)</code>竞争执行速度</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>ECMAScript 的 Job Queues 和 Event loop 有什么关系？ - flyingsoul的回答 - 知乎<br><a href="https://www.zhihu.com/question/40063533/answer/271176956" target="_blank" rel="external">https://www.zhihu.com/question/40063533/answer/271176956</a></p>
<p><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues" target="_blank" rel="external">Ecma Jobs and Jobs Queues</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" target="_blank" rel="external">Mdn Event Loop</a></p>
<p><a href="https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c" target="_blank" rel="external">What you should know to really understand the Node.js Event Loop</a></p>
<p><a href="https://medium.com/@gaurav.pandvia/understanding-javascript-function-executions-tasks-event-loop-call-stack-more-part-1-5683dea1f5ec" target="_blank" rel="external">https://medium.com/@gaurav.pandvia/understanding-javascript-function-executions-tasks-event-loop-call-stack-more-part-1-5683dea1f5ec</a></p>
<p><a href="https://stackoverflow.com/questions/10680601/nodejs-event-loop" target="_blank" rel="external">https://stackoverflow.com/questions/10680601/nodejs-event-loop</a></p>
<p><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="external">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/</a></p>
<p><a href="http://nikhilm.github.io/uvbook/introduction.html#background" target="_blank" rel="external">http://nikhilm.github.io/uvbook/introduction.html#background</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javascript/" rel="tag"># javascript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/12/from-promise-polyfill-to-eventloop/" rel="next" title="从Promise到Event Loop（一）">
                <i class="fa fa-chevron-left"></i> 从Promise到Event Loop（一）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">iveswen</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#热身"><span class="nav-number">2.</span> <span class="nav-text">热身</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-heap（堆）"><span class="nav-number">2.1.</span> <span class="nav-text">1. heap（堆）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-stack（栈）"><span class="nav-number">2.2.</span> <span class="nav-text">2. stack（栈）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Event-Loop"><span class="nav-number">2.3.</span> <span class="nav-text">3. Event Loop</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发模型和事件循环"><span class="nav-number">3.</span> <span class="nav-text">并发模型和事件循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#以“Thread”为单位"><span class="nav-number">3.1.</span> <span class="nav-text">以“Thread”为单位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-Loop-依赖js宿主环境实现"><span class="nav-number">3.2.</span> <span class="nav-text">Event Loop 依赖js宿主环境实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-Loop-是类似队列（queue-like）的结构"><span class="nav-number">3.3.</span> <span class="nav-text">Event Loop 是类似队列（queue-like）的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ecma-262的Jobs和Job-Queues"><span class="nav-number">3.4.</span> <span class="nav-text">Ecma-262的Jobs和Job Queues</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chrome的Task和MicroTask"><span class="nav-number">4.</span> <span class="nav-text">Chrome的Task和MicroTask</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类型"><span class="nav-number">4.1.</span> <span class="nav-text">类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行规则"><span class="nav-number">4.2.</span> <span class="nav-text">执行规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#node的Libuv"><span class="nav-number">5.</span> <span class="nav-text">node的Libuv</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Libuv的Event-Loop"><span class="nav-number">5.1.</span> <span class="nav-text">Libuv的Event Loop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分类"><span class="nav-number">5.2.</span> <span class="nav-text">分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Timer"><span class="nav-number">5.2.1.</span> <span class="nav-text">Timer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO-callback"><span class="nav-number">5.3.</span> <span class="nav-text">IO callback</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO-Polling"><span class="nav-number">5.4.</span> <span class="nav-text">IO Polling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Immediate"><span class="nav-number">5.5.</span> <span class="nav-text">Immediate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#close"><span class="nav-number">5.6.</span> <span class="nav-text">close</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结论"><span class="nav-number">6.</span> <span class="nav-text">结论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">7.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">iveswen</span>

  

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
